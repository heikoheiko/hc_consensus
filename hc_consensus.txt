Notation:
    H,R:    block height, round
    B:      block
    +1/n:   more than 1/nth (votes)


Round:
    The sequence (Receive-Proposal/Collect-Lockset+Timeout -> Vote) is called a round R. There may be more than one round required to commit a block at a given height H.

Votes/Locks:
    Votes are signed messages sent by validators, which sign: (H, R, [B])

    Lock(H, R, B):
        represents the vote  of a validator for a block at H,R and is locked on that block
    NotLocked(H, R)
        represents the vote that a validator is not locked on a block in H and promised to not lock in H,R they are
    Validators send their Lock/NotLocked every round, either in response to a message from the proposer or if they timeout.
    Proposers of a round R>R0 send a LockSet, which allows nodes to eventually unlock.
    Validators build their own LockSet based on received votes. +2/3 locksets let them transition to the next round.


LockSet(R):
    A valid LockSet(R) is a collection of at least +2/3 of the eligible votes in round R

    The votes in R that a designated proposer of round R collected.
    A valid LockSet must contain +2/3 of eligible votes.
    Votes can either be Locked or NotLocked on a block.

    There are three kinds of LockSets:
    Quorum: has +2/3 of all eligible votes voting for the same block
    QuorumPossible: has +1/3 of all eligible votes voting for the same block.
    NoQuorum: has at most 1/3 of all eligible votes on a block (which all could be byzantine)

VoteInstruction(R, B):
    A message which includes a QuorumPossible-LockSet(R-1) and instructs nodes to also vote
    for the block which has at least one non-byzantine vote.


Consensus Protocol:
    At each height of the blockchain a round-based protocol is run to determine the next block. Each round is composed of two steps (Propose and Vote).

    A round was successful if there is a Quroum-LockSet for a proposed block.

    In the optimal scenario, the order of steps is:
    Propose H -> Vote H -> Commit H -> Propose H+1 ...

    Commits for H are implicitly sent with proposals in H+1, as they must contain a Quorum-LockSet for a block on H. As nodes also maintain their own LockSet they commit as soon as they've seen a Quorum-LockSet. This is usually before they receive a proposal for a new block height.
    While unlikely the order of steps of a validator may also look like this:
    Propose H -> Commit H-1, Vote H -> Propose H+1 -> Commit H, Vote H+1 ...

    This async commiting is safe, because if there ever was a Quorum-LockSet, the proposer will at least have learned a QuorumPossible-LockSet which will lead to a consensus for that block.

    In order to avoid votes for conflicting proposals,
    eligible voters in each round lock by sending a vote, which is either:
    - Locked(H, R, B) if they voted for a block
    - NotLocked(H, R) if they did not yet vote on a block

    As long as a node is locked it must not vote for another block on H.
    Nodes must vote in every round (e.g. repeating older votes but signed for the new round)

    If the desigated proposer has LockSet(R-1) which is not a Quorum-LockSet it must:
    - if QuorumPossible-LockSet: broadcast a VoteInstruction message referencing the block
    - if NoQuorum-LockSet: propose a new block

    In both cases the messages contains the LockSet(R-1), which allow the
    nodes to eventually unlock and vote again (either on a block proposed in R or proposed in R-n and instructed to vote in R).


NewRound(H, R):
    if node is the designated proposer for this round
    -> Propose(H, R)
    else
    -> Listen(H, R)

Propose(H, R):
    The  proposer of the block at H,R is selected round robin from the set of validators.
    Only one validator must propose exactly one block at H,R.

    The proposer collected all votes in R-1 in a LockSet(R-1).

    If there is a QuorumPossible-LockSet the proposer broadcasts a VoteInstruction(R, B).
    Otherwise it broadcasts a new proposal,
    which is for a new block height if it knows a Quorum-LockSet

    Valid new proposals for H, R0 are blocks that
        - contain a Quorum-LockSet on a block H-1
        - describe the state change from H-1 > H
    Valid new proposals for H, R > R0 are blocks that additionally
        - include a NoQuorum-LockSet(R)


    A proposal is broadcasted as soon, as there is either a
    - Quorum-LockSet (consensus)
    - NoQuorum-LockSet (+1/3 of all votes locked on no block)
    - QuorumPossible-LockSet (+1/3 of all votes locked on a block already)

    -> Listen(H, R)


Commit(H, R):
    Is entered by a node whenever it learns about a Quorum-LockSet H,R for the first time.
    This can be by receiving a LockSet within a proposal or by adding votes to its local LockSet.

    - If the parent of block is unkown go to sync mode, else:
    - Commit the block referenced by the Quorum-LockSet
    - unlock
    -> NewRound(H+1, R0)


Listen:
    The timeout counter on round R of a validator starts once it collected a valid LockSet(R)

    On message(H, R):
        if is vote from eligible voter:
            - update LockSet
            - if we have a Quorum-LockSet(H, R)
                -> Commit(H)
        if is proposal(H, R) from designated proposer:
            valid proposals contain a QuorumLockset on a H-1
                - commit H-1 if not yet
            - if Quorum-LockSet(R-1):
                -> Commit(H)
            - else
                Vote(H, R)

    On Timeout:
    - timeout for the current height is increased
    - If validator is locked on a block B from a previous round, it broadcasts Lock(H, R, B)
    - If validator is not locked, it broadcasts NotLocked(H, R)
    -> NewRound(H, R+1)


Vote(H, R):

    Case: Validator receives a valid proposal (i.e. with a valid LockSet(R-1)) B for H, R.
    - If it is locked on a block it unlocks
    - It locks on the new proposal
    - It broadcasts a new Lock(H, R, B)

    Case: Validator receives an invalid proposal for H, R
    - If it is locked, it broadcasts Locked(H, R, B)
    - If it is not locked, it broadcasts NotLocked(H, R)

    Case: Validator receives a valid VoteInstruction H, R
    - If it is locked on a block it unlocks
    - it locks on B from the VoteInstruction
    - It broadcasts a Lock(H, R, B)

    Valid Proposals/VoteInstructions must have  H>H_last or H=H_last,R>R_last and
    must be signed by the designated proposer of H,R.
    Invalid Proposals are ignored.

    FIXME: Explain why edgcase where parts already commited and there is a proposer on H+1,R0 and one H, Rn

    -> NewRound(H, R+1)



Proof of Safety

Assume that at most -1/3 of the voting power of validators is byzantine.
If n validator commits block B at round R, it's because it saw +2/3 of votes at round R.
This implies that +1/3 of honest nodes are still locked at round R' > R.
These locked validators will remain locked until they receive a NoQuorum-LockSet at R' > R from the designated proposer. But this won't happen because +1/3 are locked and honest, the QuorumPossible-LockSet is the only valid LockSet, which doesn't allow to vote on a different block.


Proof of Liveness

If +1/3 honest validators are locked on two different blocks from different rounds, a proposers' NoQuorum- or QuorumPossible-LockSet will eventually cause nodes locked from the earlier round to unlock.
Designated proposer of R>0 are aware of the locks from the previous round.
There are no locks when entering H,R0. Timeout length increment with every new round, while the size of blocks and the LockSet are capped, so eventually the network is able to transport the whole proposal in time.

